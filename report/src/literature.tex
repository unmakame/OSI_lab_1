\section{Исходная программа}

\begin{center}
\lstinputlisting[language=C++,caption={main.cpp - точка входа, создает ParentProcess},captionpos=b]{src/main.cpp}
\end{center}

\begin{center}
\lstinputlisting[language=C++,caption={parentProcess.cpp - класс ParentProcess, управляет дочерними процессами},captionpos=b]{src/parentProcess.cpp}
\end{center}

\begin{center}
\lstinputlisting[language=C++,caption={parentProcessImplementation.cpp - реализация родительского процесса},captionpos=b]{src/parentProcessImplementation.cpp}
\end{center}

\begin{center}
\lstinputlisting[language=C++,caption={childProcess.cpp - дочерний процесс для обработки строк},captionpos=b]{src/childProcess.cpp}
\end{center}

\begin{center}
\lstinputlisting[language=C++,caption={pipeManager.cpp - класс PipeManager, работа с каналами},captionpos=b]{src/pipeManager.cpp}
\end{center}

\begin{center}
\lstinputlisting[language=C++,caption={stringProcessor.cpp - класс StringProcessor, обработка строк},captionpos=b]{src/stringProcessor.cpp}
\end{center}

\section{Системные вызовы}

\begin{verbatim}
274130 execve("./parentProcess", ["./parentProcess"], 0x7ffcd3e49d68 /* 36 vars */) = 0
274130 brk(NULL)                        = 0x63bd01b85000
274130 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79c2f692d000
274130 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
274130 openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
274130 fstat(3, {st_mode=S_IFREG|0644, st_size=33163, ...}) = 0
274130 mmap(NULL, 33163, PROT_READ, MAP_PRIVATE, 3, 0) = 0x79c2f6924000
274130 close(3)                         = 0
274130 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libstdc++.so.6", O_RDONLY|O_CLOEXEC) = 3
274130 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
274130 fstat(3, {st_mode=S_IFREG|0644, st_size=2592224, ...}) = 0
274130 mmap(NULL, 2609472, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79c2f6600000
274130 mmap(0x79c2f669d000, 1343488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x9d000) = 0x79c2f669d000
274130 mmap(0x79c2f67e5000, 552960, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e5000) = 0x79c2f67e5000
274130 mmap(0x79c2f686c000, 57344, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x26b000) = 0x79c2f686c000
274130 mmap(0x79c2f687a000, 12608, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79c2f687a000
274130 close(3)                         = 0
274130 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3
274130 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
274130 fstat(3, {st_mode=S_IFREG|0644, st_size=183024, ...}) = 0
274130 mmap(NULL, 185256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79c2f68f6000
274130 mmap(0x79c2f68fa000, 147456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x4000) = 0x79c2f68fa000
274130 mmap(0x79c2f691e000, 16384, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x79c2f691e000
274130 mmap(0x79c2f6922000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2b000) = 0x79c2f6922000
274130 close(3)                         = 0
274130 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
274130 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\243\2\0\0\0\0\0"..., 832) = 832
274130 pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
274130 fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
274130 pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
274130 mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79c2f6200000
274130 mmap(0x79c2f6228000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x79c2f6228000
274130 mmap(0x79c2f63b0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x79c2f63b0000
274130 mmap(0x79c2f63ff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x79c2f63ff000
274130 mmap(0x79c2f6405000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79c2f6405000
274130 close(3)                         = 0
274130 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
274130 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
274130 fstat(3, {st_mode=S_IFREG|0644, st_size=952616, ...}) = 0
274130 mmap(NULL, 950296, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79c2f6517000
274130 mmap(0x79c2f6527000, 520192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x10000) = 0x79c2f6527000
274130 mmap(0x79c2f65a6000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x8f000) = 0x79c2f65a6000
274130 mmap(0x79c2f65fe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe7000) = 0x79c2f65fe000
274130 close(3)                         = 0
274130 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79c2f68f4000
274130 mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79c2f68f1000
274130 arch_prctl(ARCH_SET_FS, 0x79c2f68f1740) = 0
274130 set_tid_address(0x79c2f68f1a10)  = 274130
274130 set_robust_list(0x79c2f68f1a20, 24) = 0
274130 rseq(0x79c2f68f2060, 0x20, 0, 0x53053053) = 0
274130 mprotect(0x79c2f63ff000, 16384, PROT_READ) = 0
274130 mprotect(0x79c2f65fe000, 4096, PROT_READ) = 0
274130 mprotect(0x79c2f6922000, 4096, PROT_READ) = 0
274130 mprotect(0x79c2f686c000, 45056, PROT_READ) = 0
274130 mprotect(0x63bcc532c000, 4096, PROT_READ) = 0
274130 mprotect(0x79c2f6965000, 8192, PROT_READ) = 0
274130 prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
274130 munmap(0x79c2f6924000, 33163)    = 0
274130 futex(0x79c2f687a7bc, FUTEX_WAKE_PRIVATE, 2147483647) = 0
274130 getrandom("\x2c\x58\x54\xd0\x53\xf6\x8a\x94", 8, GRND_NONBLOCK) = 8
274130 brk(NULL)                        = 0x63bd01b85000
274130 brk(0x63bd01ba6000)              = 0x63bd01ba6000
274130 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x5), ...}) = 0
274130 write(1, "Enter filename for child1: ", 27) = 27
274130 fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x5), ...}) = 0
274130 read(0, "file1.txt\n", 1024)     = 10
274130 write(1, "Enter filename for child2: ", 27) = 27
274130 read(0, "file2.txt\n", 1024)     = 10
274130 pipe2([3, 4], 0)                 = 0  # Создание pipe1 для коротких строк
274130 pipe2([5, 6], 0)                 = 0  # Создание pipe2 для длинных строк
274130 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x79c2f68f1a10) = 274150
274150 set_robust_list(0x79c2f68f1a20, 24) = 0
274130 close(3)                         = 0  # Закрытие read end pipe1 в родителе
274150 close(4)                         = 0  # Закрытие write end pipe1 в child1
274130 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x79c2f68f1a10) = 274151
274130 close(5)                         = 0  # Закрытие read end pipe2 в родителе
274151 set_robust_list(0x79c2f68f1a20, 24) = 0
274130 close(3)                         = -1 EBADF (Bad file descriptor)
274151 close(6)                         = 0  # Закрытие write end pipe2 в child2
274150 execve("./childProcess", ["./childProcess", "file1.txt", "1"], 0x7ffd73be59b8 /* 36 vars */) = 0
274151 execve("./childProcess", ["./childProcess", "file2.txt", "2"], 0x7ffd73be59b8 /* 36 vars */) = 0
274130 read(0, "hello\n", 1024)         = 6
274130 write(4, "hello", 5)             = 5  # Запись короткой строки в pipe1
274130 write(4, "\n", 1)                = 1
274150 read(3, "hello", 255)            = 5  # Чтение из pipe1 в child1
274150 write(1, "Child1 processed: 'hello' -> 'hll'", 35) = 35  # Вывод результата
274130 read(0, "very long string\n", 1024) = 17
274130 write(6, "very long string", 16)  = 16 # Запись длинной строки в pipe2
274130 write(6, "\n", 1)                = 1
274151 read(5, "very long string", 255)  = 16 # Чтение из pipe2 в child2
274151 write(1, "Child2 processed: 'very long string' -> 'vry lng strng'", 55) = 55
274130 read(0, "test\n", 1024)          = 5
274130 write(4, "test", 4)              = 4  # Запись короткой строки в pipe1
274130 write(4, "\n", 1)                = 1
274150 read(3, "test", 255)             = 4  # Чтение из pipe1 в child1
274150 write(1, "Child1 processed: 'test' -> 'tst'", 34) = 34
274130 read(0, "\n", 1024)              = 1  # Пустая строка - завершение
274130 close(4)                         = 0  # Закрытие write end pipe1
274130 close(6)                         = 0  # Закрытие write end pipe2
274130 wait4(274150, NULL, 0, NULL)     = 274150  # Ожидание завершения child1
274130 wait4(274151, NULL, 0, NULL)     = 274151  # Ожидание завершения child2
274130 write(1, "Parent process finished.", 24) = 24
274130 exit_group(0)                    = ?
274150 exit_group(0)                    = ?
274151 exit_group(0)                    = ?
\end{verbatim}

\subsection{Анализ системных вызовов}

В ходе выполнения программы были использованы следующие ключевые системные вызовы:

\begin{itemize}
    \item \texttt{pipe2([3, 4], 0)} - создание первого канала (pipe1) для коротких строк
    \item \texttt{pipe2([5, 6], 0)} - создание второго канала (pipe2) для длинных строк  
    \item \texttt{clone()} - создание дочерних процессов с флагами CLONE\_CHILD\_CLEARTID | CLONE\_CHILD\_SETTID | SIGCHLD
    \item \texttt{execve()} - запуск дочерних процессов с передачей параметров (имя файла и номер процесса)
    \item \texttt{write(4, "hello", 5)} - запись короткой строки в pipe1 (дескриптор 4)
    \item \texttt{write(6, "very long string", 16)} - запись длинной строки в pipe2 (дескриптор 6)
    \item \texttt{read(3, "hello", 255)} - чтение из pipe1 в дочернем процессе (дескриптор 3)
    \item \texttt{read(5, "very long string", 255)} - чтение из pipe2 в дочернем процессе (дескриптор 5)
    \item \texttt{wait4()} - ожидание завершения дочерних процессов
\end{itemize}

Программа демонстрирует корректную работу механизма межпроцессного взаимодействия через именованные каналы и правильное распределение строк между процессами согласно варианту 17.